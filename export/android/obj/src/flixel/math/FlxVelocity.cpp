// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_touch_FlxTouch
#include <flixel/input/touch/FlxTouch.h>
#endif
#ifndef INCLUDED_flixel_math_FlxAngle
#include <flixel/math/FlxAngle.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxVelocity
#include <flixel/math/FlxVelocity.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_efb42de64cd9f379_24_moveTowardsObject,"flixel.math.FlxVelocity","moveTowardsObject",0xaf722b77,"flixel.math.FlxVelocity.moveTowardsObject","flixel/math/FlxVelocity.hx",24,0xbea30ec3)
HX_DEFINE_STACK_FRAME(_hx_pos_efb42de64cd9f379_50_accelerateTowardsObject,"flixel.math.FlxVelocity","accelerateTowardsObject",0x1ebf81eb,"flixel.math.FlxVelocity.accelerateTowardsObject","flixel/math/FlxVelocity.hx",50,0xbea30ec3)
HX_DEFINE_STACK_FRAME(_hx_pos_efb42de64cd9f379_95_moveTowardsTouch,"flixel.math.FlxVelocity","moveTowardsTouch",0x60a86a07,"flixel.math.FlxVelocity.moveTowardsTouch","flixel/math/FlxVelocity.hx",95,0xbea30ec3)
HX_DEFINE_STACK_FRAME(_hx_pos_efb42de64cd9f379_141_accelerateTowardsTouch,"flixel.math.FlxVelocity","accelerateTowardsTouch",0x35889e13,"flixel.math.FlxVelocity.accelerateTowardsTouch","flixel/math/FlxVelocity.hx",141,0xbea30ec3)
HX_DEFINE_STACK_FRAME(_hx_pos_efb42de64cd9f379_160_moveTowardsPoint,"flixel.math.FlxVelocity","moveTowardsPoint",0x13050698,"flixel.math.FlxVelocity.moveTowardsPoint","flixel/math/FlxVelocity.hx",160,0xbea30ec3)
HX_DEFINE_STACK_FRAME(_hx_pos_efb42de64cd9f379_188_accelerateTowardsPoint,"flixel.math.FlxVelocity","accelerateTowardsPoint",0xe7e53aa4,"flixel.math.FlxVelocity.accelerateTowardsPoint","flixel/math/FlxVelocity.hx",188,0xbea30ec3)
HX_DEFINE_STACK_FRAME(_hx_pos_efb42de64cd9f379_204_velocityFromAngle,"flixel.math.FlxVelocity","velocityFromAngle",0x954f2639,"flixel.math.FlxVelocity.velocityFromAngle","flixel/math/FlxVelocity.hx",204,0xbea30ec3)
HX_DEFINE_STACK_FRAME(_hx_pos_efb42de64cd9f379_218_velocityFromFacing,"flixel.math.FlxVelocity","velocityFromFacing",0x90de75f4,"flixel.math.FlxVelocity.velocityFromFacing","flixel/math/FlxVelocity.hx",218,0xbea30ec3)
HX_DEFINE_STACK_FRAME(_hx_pos_efb42de64cd9f379_234_computeVelocity,"flixel.math.FlxVelocity","computeVelocity",0xd7550d81,"flixel.math.FlxVelocity.computeVelocity","flixel/math/FlxVelocity.hx",234,0xbea30ec3)
HX_DEFINE_STACK_FRAME(_hx_pos_efb42de64cd9f379_280_accelerateFromAngle,"flixel.math.FlxVelocity","accelerateFromAngle",0x5b8d48b9,"flixel.math.FlxVelocity.accelerateFromAngle","flixel/math/FlxVelocity.hx",280,0xbea30ec3)
namespace flixel{
namespace math{

void FlxVelocity_obj::__construct() { }

Dynamic FlxVelocity_obj::__CreateEmpty() { return new FlxVelocity_obj; }

void *FlxVelocity_obj::_hx_vtable = 0;

Dynamic FlxVelocity_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxVelocity_obj > _hx_result = new FlxVelocity_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxVelocity_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x252d0a87;
}

void FlxVelocity_obj::moveTowardsObject( ::flixel::FlxSprite Source, ::flixel::FlxSprite Dest,hx::Null< Float >  __o_Speed,hx::Null< int >  __o_MaxTime){
Float Speed = __o_Speed.Default(60);
int MaxTime = __o_MaxTime.Default(0);
            	HX_STACKFRAME(&_hx_pos_efb42de64cd9f379_24_moveTowardsObject)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Dest,"Dest")
            	HX_STACK_ARG(Speed,"Speed")
            	HX_STACK_ARG(MaxTime,"MaxTime")
HXLINE(  25)		HX_VAR( Float,a);
HXDLIN(  25)		a = ::Math_obj::atan2(((Dest->y + Dest->origin->y) - (Source->y + Source->origin->y)),((Dest->x + Dest->origin->x) - (Source->x + Source->origin->x)));
HXLINE(  27)		if ((MaxTime > (int)0)) {
HXLINE(  29)			HX_VARI( Float,dx) = ((Source->x + Source->origin->x) - (Dest->x + Dest->origin->x));
HXDLIN(  29)			HX_VARI( Float,dy) = ((Source->y + Source->origin->y) - (Dest->y + Dest->origin->y));
HXLINE(  32)			Speed = ::Std_obj::_hx_int(((Float)::Std_obj::_hx_int(::Math_obj::sqrt(((dx * dx) + (dy * dy)))) / (Float)((Float)MaxTime / (Float)(int)1000)));
            		}
HXLINE(  35)		Source->velocity->set_x((::Math_obj::cos(a) * Speed));
HXLINE(  36)		Source->velocity->set_y((::Math_obj::sin(a) * Speed));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxVelocity_obj,moveTowardsObject,(void))

void FlxVelocity_obj::accelerateTowardsObject( ::flixel::FlxSprite Source, ::flixel::FlxSprite Dest,Float Acceleration,Float MaxSpeed){
            	HX_STACKFRAME(&_hx_pos_efb42de64cd9f379_50_accelerateTowardsObject)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Dest,"Dest")
            	HX_STACK_ARG(Acceleration,"Acceleration")
            	HX_STACK_ARG(MaxSpeed,"MaxSpeed")
HXLINE(  51)		HX_VAR( Float,a);
HXDLIN(  51)		a = ::Math_obj::atan2(((Dest->y + Dest->origin->y) - (Source->y + Source->origin->y)),((Dest->x + Dest->origin->x) - (Source->x + Source->origin->x)));
HXLINE(  52)		{
HXLINE(  52)			HX_VARI( Float,sinA) = ::Math_obj::sin(a);
HXDLIN(  52)			HX_VARI( Float,cosA) = ::Math_obj::cos(a);
HXDLIN(  52)			Source->velocity->set((int)0,(int)0);
HXDLIN(  52)			Source->acceleration->set((cosA * Acceleration),(sinA * Acceleration));
HXDLIN(  52)			Source->maxVelocity->set(::Math_obj::abs((cosA * MaxSpeed)),::Math_obj::abs((sinA * MaxSpeed)));
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxVelocity_obj,accelerateTowardsObject,(void))

void FlxVelocity_obj::moveTowardsTouch( ::flixel::FlxSprite Source, ::flixel::input::touch::FlxTouch Touch,hx::Null< Float >  __o_Speed,hx::Null< int >  __o_MaxTime){
Float Speed = __o_Speed.Default(60);
int MaxTime = __o_MaxTime.Default(0);
            	HX_STACKFRAME(&_hx_pos_efb42de64cd9f379_95_moveTowardsTouch)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Touch,"Touch")
            	HX_STACK_ARG(Speed,"Speed")
            	HX_STACK_ARG(MaxTime,"MaxTime")
HXLINE(  96)		HX_VARI(  ::flixel::math::FlxPoint,p) = Source->getScreenPosition(null(),null());
HXDLIN(  96)		HX_VARI( Float,dx) = (Touch->screenX - p->x);
HXDLIN(  96)		HX_VARI( Float,dy) = (Touch->screenY - p->y);
HXDLIN(  96)		p->put();
HXDLIN(  96)		HX_VAR( Float,a);
HXDLIN(  96)		a = ::Math_obj::atan2(dy,dx);
HXLINE(  98)		if ((MaxTime > (int)0)) {
HXLINE( 100)			HX_VARI_NAME( Float,dx1,"dx") = ((Source->x + Source->origin->x) - Touch->screenX);
HXDLIN( 100)			HX_VARI_NAME( Float,dy1,"dy") = ((Source->y + Source->origin->y) - Touch->screenY);
HXLINE( 103)			Speed = ::Std_obj::_hx_int(((Float)::Std_obj::_hx_int(::Math_obj::sqrt(((dx1 * dx1) + (dy1 * dy1)))) / (Float)((Float)MaxTime / (Float)(int)1000)));
            		}
HXLINE( 106)		Source->velocity->set_x((::Math_obj::cos(a) * Speed));
HXLINE( 107)		Source->velocity->set_y((::Math_obj::sin(a) * Speed));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxVelocity_obj,moveTowardsTouch,(void))

void FlxVelocity_obj::accelerateTowardsTouch( ::flixel::FlxSprite Source, ::flixel::input::touch::FlxTouch Touch,Float Acceleration,Float MaxSpeed){
            	HX_STACKFRAME(&_hx_pos_efb42de64cd9f379_141_accelerateTowardsTouch)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Touch,"Touch")
            	HX_STACK_ARG(Acceleration,"Acceleration")
            	HX_STACK_ARG(MaxSpeed,"MaxSpeed")
HXLINE( 142)		HX_VARI(  ::flixel::math::FlxPoint,p) = Source->getScreenPosition(null(),null());
HXDLIN( 142)		HX_VARI( Float,dx) = (Touch->screenX - p->x);
HXDLIN( 142)		HX_VARI( Float,dy) = (Touch->screenY - p->y);
HXDLIN( 142)		p->put();
HXDLIN( 142)		HX_VAR( Float,a);
HXDLIN( 142)		a = ::Math_obj::atan2(dy,dx);
HXLINE( 144)		{
HXLINE( 144)			HX_VARI( Float,sinA) = ::Math_obj::sin(a);
HXDLIN( 144)			HX_VARI( Float,cosA) = ::Math_obj::cos(a);
HXDLIN( 144)			Source->velocity->set((int)0,(int)0);
HXDLIN( 144)			Source->acceleration->set((cosA * Acceleration),(sinA * Acceleration));
HXDLIN( 144)			Source->maxVelocity->set(::Math_obj::abs((cosA * MaxSpeed)),::Math_obj::abs((sinA * MaxSpeed)));
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxVelocity_obj,accelerateTowardsTouch,(void))

void FlxVelocity_obj::moveTowardsPoint( ::flixel::FlxSprite Source, ::flixel::math::FlxPoint Target,hx::Null< Float >  __o_Speed,hx::Null< int >  __o_MaxTime){
Float Speed = __o_Speed.Default(60);
int MaxTime = __o_MaxTime.Default(0);
            	HX_STACKFRAME(&_hx_pos_efb42de64cd9f379_160_moveTowardsPoint)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Target,"Target")
            	HX_STACK_ARG(Speed,"Speed")
            	HX_STACK_ARG(MaxTime,"MaxTime")
HXLINE( 161)		HX_VARI( Float,a) = ::flixel::math::FlxAngle_obj::angleBetweenPoint(Source,Target,null());
HXLINE( 163)		if ((MaxTime > (int)0)) {
HXLINE( 165)			HX_VARI( Float,dx) = ((Source->x + Source->origin->x) - Target->x);
HXDLIN( 165)			HX_VARI( Float,dy) = ((Source->y + Source->origin->y) - Target->y);
HXDLIN( 165)			if (Target->_weak) {
HXLINE( 165)				Target->put();
            			}
HXLINE( 168)			Speed = ::Std_obj::_hx_int(((Float)::Std_obj::_hx_int(::Math_obj::sqrt(((dx * dx) + (dy * dy)))) / (Float)((Float)MaxTime / (Float)(int)1000)));
            		}
HXLINE( 171)		Source->velocity->set_x((::Math_obj::cos(a) * Speed));
HXLINE( 172)		Source->velocity->set_y((::Math_obj::sin(a) * Speed));
HXLINE( 174)		if (Target->_weak) {
HXLINE( 174)			Target->put();
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxVelocity_obj,moveTowardsPoint,(void))

void FlxVelocity_obj::accelerateTowardsPoint( ::flixel::FlxSprite Source, ::flixel::math::FlxPoint Target,Float Acceleration,Float MaxSpeed){
            	HX_STACKFRAME(&_hx_pos_efb42de64cd9f379_188_accelerateTowardsPoint)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Target,"Target")
            	HX_STACK_ARG(Acceleration,"Acceleration")
            	HX_STACK_ARG(MaxSpeed,"MaxSpeed")
HXLINE( 189)		HX_VARI( Float,a) = ::flixel::math::FlxAngle_obj::angleBetweenPoint(Source,Target,null());
HXLINE( 191)		{
HXLINE( 191)			HX_VARI( Float,sinA) = ::Math_obj::sin(a);
HXDLIN( 191)			HX_VARI( Float,cosA) = ::Math_obj::cos(a);
HXDLIN( 191)			Source->velocity->set((int)0,(int)0);
HXDLIN( 191)			Source->acceleration->set((cosA * Acceleration),(sinA * Acceleration));
HXDLIN( 191)			Source->maxVelocity->set(::Math_obj::abs((cosA * MaxSpeed)),::Math_obj::abs((sinA * MaxSpeed)));
            		}
HXLINE( 193)		if (Target->_weak) {
HXLINE( 193)			Target->put();
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxVelocity_obj,accelerateTowardsPoint,(void))

 ::flixel::math::FlxPoint FlxVelocity_obj::velocityFromAngle(Float Angle,Float Speed){
            	HX_STACKFRAME(&_hx_pos_efb42de64cd9f379_204_velocityFromAngle)
            	HX_STACK_ARG(Angle,"Angle")
            	HX_STACK_ARG(Speed,"Speed")
HXLINE( 205)		HX_VARI( Float,a) = (Angle * ((Float)::Math_obj::PI / (Float)(int)180));
HXLINE( 207)		Float X = (::Math_obj::cos(a) * Speed);
HXDLIN( 207)		Float Y = (::Math_obj::sin(a) * Speed);
HXDLIN( 207)		HX_VARI(  ::flixel::math::FlxPoint,point) = ::flixel::math::FlxPoint_obj::_pool->get().StaticCast<  ::flixel::math::FlxPoint >()->set(X,Y);
HXDLIN( 207)		point->_inPool = false;
HXDLIN( 207)		return point;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxVelocity_obj,velocityFromAngle,return )

 ::flixel::math::FlxPoint FlxVelocity_obj::velocityFromFacing( ::flixel::FlxSprite Parent,Float Speed){
            	HX_STACKFRAME(&_hx_pos_efb42de64cd9f379_218_velocityFromFacing)
            	HX_STACK_ARG(Parent,"Parent")
            	HX_STACK_ARG(Speed,"Speed")
HXLINE( 219)		HX_VARI( int,FacingBitmask) = Parent->facing;
HXDLIN( 219)		HX_VAR( int,degrees);
HXDLIN( 219)		switch((int)(FacingBitmask)){
            			case (int)1: {
HXLINE( 219)				degrees = (int)180;
            			}
            			break;
            			case (int)16: {
HXLINE( 219)				degrees = (int)0;
            			}
            			break;
            			case (int)256: {
HXLINE( 219)				degrees = (int)-90;
            			}
            			break;
            			case (int)4096: {
HXLINE( 219)				degrees = (int)90;
            			}
            			break;
            			default:{
HXLINE( 219)				if ((FacingBitmask == (int)257)) {
HXLINE( 219)					degrees = (int)-135;
            				}
            				else {
HXLINE( 219)					if ((FacingBitmask == (int)272)) {
HXLINE( 219)						degrees = (int)-45;
            					}
            					else {
HXLINE( 219)						if ((FacingBitmask == (int)4097)) {
HXLINE( 219)							degrees = (int)135;
            						}
            						else {
HXLINE( 219)							if ((FacingBitmask == (int)4112)) {
HXLINE( 219)								degrees = (int)45;
            							}
            							else {
HXLINE( 219)								degrees = (int)0;
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 219)		HX_VAR( Float,a);
HXDLIN( 219)		a = (degrees * ((Float)::Math_obj::PI / (Float)(int)180));
HXLINE( 220)		Float X = (::Math_obj::cos(a) * Speed);
HXDLIN( 220)		Float Y = (::Math_obj::sin(a) * Speed);
HXDLIN( 220)		HX_VARI(  ::flixel::math::FlxPoint,point) = ::flixel::math::FlxPoint_obj::_pool->get().StaticCast<  ::flixel::math::FlxPoint >()->set(X,Y);
HXDLIN( 220)		point->_inPool = false;
HXDLIN( 220)		return point;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxVelocity_obj,velocityFromFacing,return )

Float FlxVelocity_obj::computeVelocity(Float Velocity,Float Acceleration,Float Drag,Float Max,Float Elapsed){
            	HX_STACKFRAME(&_hx_pos_efb42de64cd9f379_234_computeVelocity)
            	HX_STACK_ARG(Velocity,"Velocity")
            	HX_STACK_ARG(Acceleration,"Acceleration")
            	HX_STACK_ARG(Drag,"Drag")
            	HX_STACK_ARG(Max,"Max")
            	HX_STACK_ARG(Elapsed,"Elapsed")
HXLINE( 235)		if ((Acceleration != (int)0)) {
HXLINE( 237)			Velocity = (Velocity + (Acceleration * Elapsed));
            		}
            		else {
HXLINE( 239)			if ((Drag != (int)0)) {
HXLINE( 241)				HX_VARI( Float,drag) = (Drag * Elapsed);
HXLINE( 242)				if (((Velocity - drag) > (int)0)) {
HXLINE( 244)					Velocity = (Velocity - drag);
            				}
            				else {
HXLINE( 246)					if (((Velocity + drag) < (int)0)) {
HXLINE( 248)						Velocity = (Velocity + drag);
            					}
            					else {
HXLINE( 252)						Velocity = (int)0;
            					}
            				}
            			}
            		}
HXLINE( 255)		bool _hx_tmp;
HXDLIN( 255)		if ((Velocity != (int)0)) {
HXLINE( 255)			_hx_tmp = (Max != (int)0);
            		}
            		else {
HXLINE( 255)			_hx_tmp = false;
            		}
HXDLIN( 255)		if (_hx_tmp) {
HXLINE( 257)			if ((Velocity > Max)) {
HXLINE( 259)				Velocity = Max;
            			}
            			else {
HXLINE( 261)				if ((Velocity < -(Max))) {
HXLINE( 263)					Velocity = -(Max);
            				}
            			}
            		}
HXLINE( 266)		return Velocity;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxVelocity_obj,computeVelocity,return )

void FlxVelocity_obj::accelerateFromAngle( ::flixel::FlxSprite source,Float radians,Float acceleration,Float maxSpeed,hx::Null< bool >  __o_resetVelocity){
bool resetVelocity = __o_resetVelocity.Default(true);
            	HX_STACKFRAME(&_hx_pos_efb42de64cd9f379_280_accelerateFromAngle)
            	HX_STACK_ARG(source,"source")
            	HX_STACK_ARG(radians,"radians")
            	HX_STACK_ARG(acceleration,"acceleration")
            	HX_STACK_ARG(maxSpeed,"maxSpeed")
            	HX_STACK_ARG(resetVelocity,"resetVelocity")
HXLINE( 281)		HX_VARI( Float,sinA) = ::Math_obj::sin(radians);
HXLINE( 282)		HX_VARI( Float,cosA) = ::Math_obj::cos(radians);
HXLINE( 284)		if (resetVelocity) {
HXLINE( 285)			source->velocity->set((int)0,(int)0);
            		}
HXLINE( 287)		source->acceleration->set((cosA * acceleration),(sinA * acceleration));
HXLINE( 288)		source->maxVelocity->set(::Math_obj::abs((cosA * maxSpeed)),::Math_obj::abs((sinA * maxSpeed)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxVelocity_obj,accelerateFromAngle,(void))


FlxVelocity_obj::FlxVelocity_obj()
{
}

bool FlxVelocity_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 15:
		if (HX_FIELD_EQ(inName,"computeVelocity") ) { outValue = computeVelocity_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"moveTowardsTouch") ) { outValue = moveTowardsTouch_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"moveTowardsPoint") ) { outValue = moveTowardsPoint_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"moveTowardsObject") ) { outValue = moveTowardsObject_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"velocityFromAngle") ) { outValue = velocityFromAngle_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"velocityFromFacing") ) { outValue = velocityFromFacing_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"accelerateFromAngle") ) { outValue = accelerateFromAngle_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"accelerateTowardsTouch") ) { outValue = accelerateTowardsTouch_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"accelerateTowardsPoint") ) { outValue = accelerateTowardsPoint_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"accelerateTowardsObject") ) { outValue = accelerateTowardsObject_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *FlxVelocity_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *FlxVelocity_obj_sStaticStorageInfo = 0;
#endif

static void FlxVelocity_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxVelocity_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxVelocity_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxVelocity_obj::__mClass,"__mClass");
};

#endif

hx::Class FlxVelocity_obj::__mClass;

static ::String FlxVelocity_obj_sStaticFields[] = {
	HX_HCSTRING("moveTowardsObject","\x6a","\x65","\x02","\x02"),
	HX_HCSTRING("accelerateTowardsObject","\x1e","\x34","\xa0","\x7d"),
	HX_HCSTRING("moveTowardsTouch","\x74","\xef","\x0c","\xc6"),
	HX_HCSTRING("accelerateTowardsTouch","\x40","\x73","\x42","\x19"),
	HX_HCSTRING("moveTowardsPoint","\x05","\x8c","\x69","\x78"),
	HX_HCSTRING("accelerateTowardsPoint","\xd1","\x0f","\x9f","\xcb"),
	HX_HCSTRING("velocityFromAngle","\x2c","\x60","\xdf","\xe7"),
	HX_HCSTRING("velocityFromFacing","\xa1","\xf0","\x80","\x7c"),
	HX_HCSTRING("computeVelocity","\xb4","\xd4","\x7e","\xb6"),
	HX_HCSTRING("accelerateFromAngle","\x6c","\x25","\x16","\x9e"),
	::String(null())
};

void FlxVelocity_obj::__register()
{
	hx::Object *dummy = new FlxVelocity_obj;
	FlxVelocity_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.math.FlxVelocity","\x3b","\x6f","\xef","\x61");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxVelocity_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = FlxVelocity_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxVelocity_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< FlxVelocity_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxVelocity_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxVelocity_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxVelocity_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace math
